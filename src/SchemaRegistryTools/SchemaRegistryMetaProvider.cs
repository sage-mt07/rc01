using Avro;
using Avro.Generic;
using System.Linq;
using Confluent.SchemaRegistry;
using Kafka.Ksql.Linq.Core.Models;
using System;
using System.Collections.Generic;

namespace Kafka.Ksql.Linq.SchemaRegistryTools;

/// <summary>
/// Utility methods to fetch Avro schemas from Schema Registry and
/// convert them into PropertyMeta arrays for Mapping registration.
/// </summary>
public static class SchemaRegistryMetaProvider
{
    /// <summary>
    /// Fetch key and value schemas for the given entity type and
    /// generate corresponding PropertyMeta definitions.
    /// </summary>
    /// <param name="entityType">Entity type registered in Kafka.</param>
    /// <param name="client">Schema Registry client.</param>
    /// <returns>Tuple of key and value PropertyMeta arrays.</returns>
    public static (PropertyMeta[] KeyProperties, PropertyMeta[] ValueProperties) GetMetaFromSchemaRegistry(
        Type entityType,
        ISchemaRegistryClient client)
    {
        if (entityType == null) throw new ArgumentNullException(nameof(entityType));
        if (client == null) throw new ArgumentNullException(nameof(client));

        var ns = entityType.Namespace?.ToLower() ?? string.Empty;
        var baseName = entityType.Name.ToLower();

        var keySubject = $"{ns}.{baseName}-key";
        var valueSubject = $"{ns}.{baseName}-value";

        var keySchema = client.GetLatestSchemaAsync(keySubject).GetAwaiter().GetResult().SchemaString;
        var valueSchema = client.GetLatestSchemaAsync(valueSubject).GetAwaiter().GetResult().SchemaString;

        var keyMeta = ParseSchema(keySchema);
        var valueMeta = ParseSchema(valueSchema);
        return (keyMeta, valueMeta);
    }

    private static PropertyMeta[] ParseSchema(string avroSchema)
    {
        var schema = Avro.Schema.Parse(avroSchema) as RecordSchema
            ?? throw new InvalidOperationException("Expected record schema");

        var metas = new List<PropertyMeta>();
        foreach (var field in schema.Fields)
        {
            var clrType = AvroTypeToClrType(field.Schema);
            metas.Add(new PropertyMeta
            {
                Name = field.Name,
                PropertyType = clrType,
                IsNullable = field.Schema is UnionSchema u && u.Schemas.Any(s => s.Tag == Avro.Schema.Type.Null),
                Precision = null,
                Scale = null,
                Format = null,
                Attributes = Array.Empty<Attribute>(),
                PropertyInfo = null,
                IsAutoGenerated = false
            });
        }
        return metas.ToArray();
    }

    private static Type AvroTypeToClrType(Avro.Schema schema)
    {
        if (schema is UnionSchema union)
        {
            foreach (var inner in union.Schemas)
            {
                if (inner.Tag != Avro.Schema.Type.Null)
                    return AvroTypeToClrType(inner);
            }
            return typeof(string);
        }

        return schema.Tag switch
        {
            Avro.Schema.Type.String => typeof(string),
            Avro.Schema.Type.Int => typeof(int),
            Avro.Schema.Type.Long => typeof(long),
            Avro.Schema.Type.Boolean => typeof(bool),
            Avro.Schema.Type.Bytes => typeof(byte[]),
            Avro.Schema.Type.Float => typeof(float),
            Avro.Schema.Type.Double => typeof(double),
            _ => typeof(string)
        };
    }
}
