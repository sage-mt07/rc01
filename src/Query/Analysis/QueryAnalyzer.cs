using Kafka.Ksql.Linq.Core.Models;
using Kafka.Ksql.Linq.Query.Schema;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

namespace Kafka.Ksql.Linq.Query.Analysis;


/// <summary>
/// Analysis engine to extract a QuerySchema from a LINQ expression
/// </summary>
public static class QueryAnalyzer
{
    /// <summary>
    /// Analyze a LINQ expression and generate a QuerySchema
    /// </summary>
    public static QuerySchemaResult AnalyzeQuery<TSource, TTarget>(
        Expression<Func<IQueryable<TSource>, IQueryable<TTarget>>> queryExpression,
        bool autoKey = true)
        where TSource : class
        where TTarget : class
    {
        try
        {
            var visitor = new QueryAnalysisVisitor();
            visitor.Visit(queryExpression.Body);

            var streamOnlyVisitor = new StreamOnlyAggregateVisitor();
            streamOnlyVisitor.Visit(queryExpression.Body);

            var schema = new QuerySchema
            {
                SourceType = typeof(TSource),
                TargetType = typeof(TTarget),
                TopicName = typeof(TTarget).Name.ToLowerInvariant(),
                UsesStreamOnlyAggregates = streamOnlyVisitor.HasStreamOnlyAggregate
            };

            schema.KeyInfo.ClassName = $"{typeof(TTarget).Name}Key";
            schema.KeyInfo.Namespace = typeof(TTarget).Namespace ?? string.Empty;
            schema.ValueInfo.ClassName = $"{typeof(TTarget).Name}Value";
            schema.ValueInfo.Namespace = typeof(TTarget).Namespace ?? string.Empty;

              // Analyze the GroupBy clause
            PropertyInfo[] keyInfos = Array.Empty<PropertyInfo>();
            if (visitor.GroupByExpression != null)
            {
                keyInfos = ExtractKeyProperties(visitor.GroupByExpression);
            }

            schema.KeyProperties = keyInfos
                .Select(p => PropertyMeta.FromProperty(p))
                .ToArray();

            if (schema.KeyProperties.Length == 0 && autoKey)
            {
                schema.KeyProperties = new[] { PropertyMeta.AutoGenerated("Id") };
            }

              // Obtain value properties via Select analysis
            schema.ValueProperties = GetAllProperties<TTarget>()
                .Select(p => PropertyMeta.FromProperty(p))
                .ToArray();

              // Validation
            var validationResult = ValidateSchema(schema);
            schema.IsValid = validationResult.Success;
            schema.Errors = validationResult.Errors;

            return QuerySchemaResult.CreateSuccess(schema);
        }
        catch (Exception ex)
        {
            return QuerySchemaResult.Failure($"Query analysis failed: {ex.Message}");
        }
    }

    /// <summary>
    /// Extract key properties from a GroupBy expression
    /// </summary>
    private static PropertyInfo[] ExtractKeyProperties(Expression groupByExpression)
    {
        if (groupByExpression is UnaryExpression unary &&
            unary.NodeType == ExpressionType.Quote &&
            unary.Operand is LambdaExpression quoted)
        {
            return ExtractPropertiesFromExpression(quoted.Body);
        }

        if (groupByExpression is LambdaExpression lambda)
        {
            return ExtractPropertiesFromExpression(lambda.Body);
        }

        return Array.Empty<PropertyInfo>();
    }

    /// <summary>
    /// Extract property information from an expression
    /// </summary>
    private static PropertyInfo[] ExtractPropertiesFromExpression(Expression expression)
    {
        var properties = new List<PropertyInfo>();

        switch (expression)
        {
            case MemberExpression member when member.Member is PropertyInfo prop:
                properties.Add(prop);
                break;

            case NewExpression newExpr:
                foreach (var arg in newExpr.Arguments)
                {
                    if (arg is MemberExpression memberArg && memberArg.Member is PropertyInfo propArg)
                    {
                        properties.Add(propArg);
                    }
                }
                break;

            case UnaryExpression unary:
                return ExtractPropertiesFromExpression(unary.Operand);
        }

        return properties.ToArray();
    }

    /// <summary>
    /// Get all properties for the given type
    /// </summary>
    private static PropertyInfo[] GetAllProperties<T>() where T : class
    {
        return typeof(T).GetProperties(BindingFlags.Public | BindingFlags.Instance);
    }

    /// <summary>
    /// Validate the schema
    /// </summary>
    private static (bool Success, List<string> Errors) ValidateSchema(QuerySchema schema)
    {
        var errors = new List<string>();

        // Check source and target types
        if (schema.SourceType == null)
            errors.Add("Source type is required");
        if (schema.TargetType == null)
            errors.Add("Target type is required");

        // Check the types of key properties
        foreach (var keyProp in schema.KeyProperties)
        {
            if (!IsSupportedKeyType(keyProp.PropertyType))
            {
                errors.Add($"Key property {keyProp.Name} has unsupported type {keyProp.PropertyType.Name}");
            }
        }

        return (errors.Count == 0, errors);
    }

    /// <summary>
    /// Determine if the key type is supported
    /// </summary>
    private static bool IsSupportedKeyType(Type type)
    {
        var underlyingType = Nullable.GetUnderlyingType(type) ?? type;
        return underlyingType == typeof(string) ||
               underlyingType == typeof(int) ||
               underlyingType == typeof(long) ||
               underlyingType == typeof(Guid);
    }
}
